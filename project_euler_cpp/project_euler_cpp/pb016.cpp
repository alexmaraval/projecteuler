//
//  pb016.cpp
//  project_euler_cpp
//
//  Created by Alexandre Maraval on 04.10.17.
//  Copyright Â© 2017 Alexandre Maraval. All rights reserved.
//

#include "pb016.hpp"

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------- CORE FUNCTIONS --------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

std::string manual_sum(const std::string &a, const std::string &b)
{
    std::string sum = "";                               // result of the sum
    std::string _a = a, _b = b;                         // temporary copies of arguments
    int s = 0, d = 0, r = 0;                            // temporary sum, digit and eventual reminder
    
    while(_a.size() < _b.size())                        // adjust size of _a
    {
        _a = "0" + _a;
    }
    while(_a.size() > _b.size())                        // adjust size of _b
    {
        _b = "0" + _b;
    }
    
    _a = "0" + _a;                                      // add one 0 in front of both _a and _b in case we have a
    _b = "0" + _b;                                      // remainder at the last iteration of the following loop
    
    for(unsigned long i = _a.size(); i>0; i--)
    {
        s = _a[i-1] + _b[i-1] + r - 2*48;               // sum of digits in column i plus remainder of previous sum, in [0,19]
        d = s%10;                                       // result digit(s)
        sum = std::to_string(d) + sum;
        r = (s-d)/10;                                   // remainder
    }
    
    if (sum[0] == '0')                                  // remove the useless occasional "0" in front of the number
    {
        sum.erase(0,1);
    }
        
    return sum;
}


std::string manual_prod(const std::string &a, const std::string &b) // need to finish
{
    std::string prod = "";                               // result of the product
    std::string _a = a, _b = b;                         // temporary copies of arguments
    int s = 0, d = 0, r = 0;                            // temporary prod, digit and eventual reminder
    
    while(_a.size() < _b.size())                        // adjust size of _a
    {
        _a = "0" + _a;
    }
    while(_a.size() > _b.size())                        // adjust size of _b
    {
        _b = "0" + _b;
    }
    
    _a = "0" + _a;                                      // add one 0 in front of both _a and _b in case we have a
    _b = "0" + _b;                                      // remainder at the last iteration of the following loop
    
    for(unsigned long i = _a.size(); i>0; i--)
    {
        s = _a[i-1] + _b[i-1] + r - 2*48;               // sum of digits in column i plus remainder of previous sum, in [0,19]
        d = s%10;                                       // result digit(s)
        prod = std::to_string(d) + prod;
        r = (s-d)/10;                                   // remainder
    }
    
    if (prod[0] == '0')                                  // remove the useless occasional "0" in front of the number
    {
        prod.erase(0,1);
    }
    
    return prod;
}


// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------- BIGINT CLASS ---------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// ----------------------------------------------------------
// -------------------- OSTREAM OPERATOR --------------------
// ----------------------------------------------------------
std::ostream &operator<< (std::ostream &os, const bigint &b)
{
    os << b._number;
    return os;
}


// ----------------------------------------------------------
// ------------------- CONSTRUCTORS et al -------------------
// ----------------------------------------------------------
bigint::bigint(std::string num){ this->_number = num;}


// ----------------------------------------------------------
// ----------------------- OPERATORS ------------------------
// ----------------------------------------------------------
bigint bigint::operator+(const bigint &b)
{
    return bigint(manual_sum(this->_number, b._number));
}


bigint bigint::operator*(const bigint &b) // need to finish
{
    return b;
}


// ----------------------------------------------------------
// ------------------ ASSIGNMENT OPERATORS ------------------
// ----------------------------------------------------------
bigint &bigint::operator= (const bigint &b)
{
    if(this != &b)
    {
        this->_number = b._number;
    }
    return *this;
};


bigint &bigint::operator= (const std::string &s)
{
    if(this->_number != s)
    {
        this->_number = s;
    }
    return *this;
};




// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------- PB016 SOLUTION --------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

void pb016()
{
    std::string n = "1";
    
    for (int i=1; i<=100; i++)
    {
        for (int j=1; j<=i; j++)
        {
            //n = n*2;
        }
        std::cout << "2^" << i << " = " << n << std::endl;
        n = 1;
    }
}
